Unit 1: Up & Going
===================


Chapter 2: Into JavaScript
~~~~~~~~~~~~~~~~~~~~~~~~~~

Values & Types
---------------

JavaScript has typed values, not typed variables. The following built-in types are available:

string
number
boolean
null and undefined
object
symbol (new to ES6)

JavaScript provides a typeof operator that can examine a value and tell you what type it is:

var a;
typeof a;       

Objects
--------

The object type refers to a compound value where you can set properties (named locations) that each hold their own values of any type.

Properties can either be accessed with dot notation (i.e., obj.a) or bracket notation (i.e., obj["a"]). Dot notation is shorter and generally easier to read, and is thus preferred when possible.

bracket notation is also useful if you want to access a property/key but the name is stored in another variable, such as:

var obj = {
    a: "hello world",
    b: 42
};

var b = "a";

obj[b];         // "hello world"
obj["b"];       // 42

Arrays
-------

difference b/w object and array declaration:

Object:	var obj = {};
Array:	var arr = [];

typeof operation will return object for both Object and Array.

Because arrays are special objects (as typeof implies), they can also have properties, including the automatically updated length property.

You theoretically could use an array as a normal object with your own named properties, or you could use an object but only give it numeric properties (0, 1, etc.) similar to an array. However, this would generally be considered improper usage of the respective types.

The best and most natural approach is to use arrays for numerically positioned values and use objects for named properties.


Functions
----------

function foo() {
    return 42;
}

foo.bar = "hello world";

typeof foo;         // "function"
typeof foo();       // "number"
typeof foo.bar;     // "string"

Functions are a subtype of objects -- typeof returns "function", which implies that a function is a main type -- and can thus have properties, but you typically will only use function object properties (like foo.bar) in limited cases.

Built-In Type Methods
---------------------

var a = "hello world";
var b = 3.14159;

a.length;               // 11
a.toUpperCase();        // "HELLO WORLD"
b.toFixed(4);           // "3.1416"

The "how" behind being able to call a.toUpperCase() is more complicated than just that method existing on the value.

Briefly, there is a String (capital S) object wrapper form, typically called a "native," that pairs with the primitive string type; it's this object wrapper that defines the toUpperCase() method on its prototype.

When you use a primitive value like "hello world" as an object by referencing a property or method (e.g., a.toUpperCase() in the previous snippet), JS automatically "boxes" the value to its object wrapper counterpart (hidden under the covers).

A string value can be wrapped by a String object, a number can be wrapped by a Number object, and a boolean can be wrapped by a Boolean object. For the most part, you don't need to worry about or directly use these object wrapper forms of the values -- prefer the primitive value forms in practically all cases and JavaScript will take care of the rest for you.


Truthy & Falsy
------------------

The "truthy" and "falsy" nature of values: when a non-boolean value is coerced to a boolean, does it become true or false, respectively?

The specific list of "falsy" values in JavaScript is as follows:

	"" (empty string)
	0, -0, NaN (invalid number)
	null, undefined
	false

Any value that's not on this "falsy" list is "truthy." Here are some examples of those:

	"hello"
	42
	true
	[ ], [ 1, "2", 3 ] (arrays)
	{ }, { a: 42 } (objects)
	function foo() { .. } (functions)

It's important to remember that a non-boolean value only follows this "truthy"/"falsy" coercion if it's actually coerced to a boolean. It's not all that difficult to confuse yourself with a situation that seems like it's coercing a value to a boolean when it's not.


Equality
----------
There are four equality operators: ==, ===, !=, and !==.

The difference between == and === is usually characterized that == checks for value equality and === checks for both value and type equality. However, this is inaccurate. The proper way to characterize them is that == checks for value equality with coercion allowed, and === checks for value equality without allowing coercion; === is often called "strict equality" for this reason.

var a = "42";
var b = 42;

a == b;         // true
a === b;        // false






























